#Ние получаваме достъп до обектите посредством променливи, които се отнасят към тях. Променливите не съдържат обектите в качеството на стойности.

from copy import *
#Описвам клас:
class MyClass:
    pass
#Създавам обект:
A = MyClass()
#Полета на обекта:
A.value = 100
A.nums = [1,2,3]
#Присвоявам референция към обекта:
B = A
#!Важно! Към този момент А и В се отнасят към ЕДИН И СЪЩИ АДРЕС в паметта и се отнасят към един и същи обект.
#Копие на обекта:
C = copy(A)
#Пълно к0опие на обекта:
D = deepcopy(A)
print(f"Създадени са обектите")
#Полета на обектите:
print(f"A: {A.value} и {A.nums}")
print(f"B: {B.value} и {B.nums}")
print(f"C: {C.value} и {C.nums}")
print(f"D: {D.value} и {D.nums}")
print()
print(f"A.value = 200 и А.nums[1] = 0")
#Нови стойности за полетата:
A.value = 200
A.nums[1] = 0

#Полета на обектите:
print(f"A: {A.value} и {A.nums}")
print(f"B: {B.value} и {B.nums}")
print(f"C: {C.value} и {C.nums}") #Обект С е 'повърхностно' копие на обект А. То се създава посредством копирането на стойностите на полетата в обект А.
#value в копие С НЕ се променя, защото неговата стойност е ЧИСЛО, а поле nums ще има същата стойност, каквато има в обект А, защото ТЕ ИМАТ ЕДИН И СЪЩ АДРЕС.
print(f"D: {D.value} и {D.nums}") #Обект D е цяло копие на обект А, съответно промени в него не се оказват.
print(f"Изтрива се А")
print()
#Във всички копия, освен в D, понеже е deepcopy(), т.е. адреса му в паметта е същия като на клас MyClass, стойностите се променят.

#Изтривам променливата:
del A
print(f"B.value = 300 и B.nums[2] = 4")
#Нови стойности за полетата:
B.value = 300
B.nums[2] = 4

#Полета на обектите:
print(f"B: {B.value} и {B.nums}")
print(f"C: {C.value} и {C.nums}")
print(f"D: {D.value} и {D.nums}")